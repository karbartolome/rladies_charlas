---
title: "R-Ladies - El uso de m√∫ltiples lenguajes en Rmarkdown"
subtitle: "‚öî<br/>with xaringan"
author: "Karina Bartolom√©"
output:
  xaringan::moon_reader:
    css: ["default", "rladies", "rladies-fonts"]
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      navigation: 
        scroll: false
    includes:
      in_header: header.html
      after_body: "collapseoutput.js"
---

```{r include=FALSE}
knitr::opts_chunk$set(comment = NA)

options(scipen=999)
```

```{r xaringan-panelset, echo=FALSE}
xaringanExtra::use_panelset()
```

background-position: 50% 50%
class: center, inverse

<img src="images/multilingual.png" width="500px" height="500px" style="position:center;">
 
# M√∫ltiples idiomas

---

background-position: 50% 50%
class: center, inverse

<img src="images/multilingual_code.png" width="500px" height="500px" style="position:center;">
 
#  M√∫ltiples lenguajes

---

# El uso de diversos lenguajes en rmarkdown

Para trabajar con distintos lenguajes en Rmarkdown, se utilizan **chunks** que referencien al lenguaje que se quiere utilizar: 

````
```{r}`r ''`
# Ac√° se escribe c√≥digo R
```
````

````
```{python}`r ''`
# Ac√° se escribe c√≥digo Python
```
````

````
```{julia}`r ''`
# Ac√° se escribe c√≥digo Python
```
````

````
```{sql}`r ''`
# Ac√° se escribe sql
```
````

Etc.

---

# R en Rmarkdown

üîπ En **Rmarkdown**, se utiliza un chunk R para cargar las librer√≠as R:

```{r Librer√≠as R, message=FALSE, warning=FALSE}
library(reticulate) # Para Python
library(tidyverse)  
library(gt) # Para tablas
```

---
```{r example-plot}

ggplot(iris) +
  aes(x = Sepal.Length) +
  geom_histogram(   #<<
    binwidth = 0.25 #<<
  )                 #<<
```

---
```{r, eval=FALSE}

{{ iris %>% }}
  {{ ggplot() + }}
  aes(x = Sepal.Length) + 
  geom_histogram(binwidth = 0.25) 
          
```

---

# Python en Rmarkdown

1.   Definir un `conda environment` a utilizar. 

En este caso, se cre√≥ un environment espec√≠fico para este proyecto. 

```{r, eval=FALSE}
reticulate::conda_create(envname='rladies', 
                         python_version="3.8.8")
```

-   Desde Anaconda, en la solapa de **Environments**, se selecciona el environment creado y se abre la terminal. Desde ah√≠, se activa con: `conda activate rladies`

Luego de finalizar el proyecto es posible eliminar este environment desde Anaconda para liberar espacio, ya que los paquetes se ir√°n instalando en ese environment. 

---

# Python en Rmarkdown

2. Se instalan los paquetes a utilizar. En este caso, lo hice desde la terminal del environment desde Anaconda:

    -   [x] ‚ûï **numpy**: conda install numpy

    -   [x] üêº **pandas**: conda install pandas 
    
    -   [x] üìä **seaborn**: conda install seaborn


3. Se define que el environment a utilizar es el que ha sido creado:

```{r}
reticulate::use_condaenv(condaenv = 'rladies', 
                         required = TRUE)
```


---

üîπSe utiliza un chunk python para cargar las librer√≠as de python:

```{python Librer√≠as python}
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
```


```{python opciones_python}
sns.set_theme(style="ticks", palette="pastel")

pd.set_option('display.max_columns', 10)
pd.set_option('display.max_colwidth', 20)

pd.set_option('display.float_format', lambda x: '%.2f' % x)
```




---

class: inverse, center, middle

# 0. Datos

---

Aclaraci√≥n!


- Los datos para esta presentaci√≥n provienen del paquete {opentradestatistics}

- Los ejemplos pueden no tener sentido real (agrupaciones de ramas de actividades que podr√≠an no tener relaci√≥n, etc.). El objetivo es utilizar datos reales para mostrar diferentes funcionalidades, no el an√°lisis de los datos en s√≠. 

- Sin embargo, siempre me parece interesante usar datos reales para motivar a quienes quieran utilizarlos luego. 



---

# Lectura de datos con R

üîπ Datos de Tidytuesday: Vignettes de paquetes en CRAN

```{r data_1, message=FALSE, echo=FALSE, eval=FALSE}
df_cran <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-03-15/cran.csv')

df_task_views <- readr::read_csv('https://raw.githubusercontent.com/karbartolome/cran-packages/main/01_data/df_task_views.csv')
```


```{r data_comercio, message=FALSE, warning=FALSE}
df_comercio  <- readr::read_csv('data/df_arg_mx.csv')
 
df_secciones <- readr::read_csv('data/df_secciones.csv')

df_commodities <- readr::read_csv('data/df_commodities.csv')
```

# Lectura de datos con python

```{python, echo=FALSE, eval=FALSE}
import os
os.chdir(f'{os.getcwd()}/02_slides')
```

```{python data_1_python, message=FALSE}
df_comercio_pd = pd.read_csv('data/df_arg_mx.csv')
```

---

```{r}
df_comercio %>% head(2)
```

‚ö° Objetos cross lenguaje  R -> Python ‚ö° 

```{python}
r.df_comercio.head(2)
```

---

Se crea una lista de variables relevantes en un chunk python: 

```{python}
variables = ['year','commodity_code','trade_value_usd_exp']
```

-------------------------------------------

üîπ Dos chunks que generan el mismo output: 

.panelset[

.panel[.panel-name[R con objeto Python]

````
```{r}`r ''`
py$df_comercio_pd %>% 
  select(all_of(py$variables)) %>% 
  head(2)
```
````

```{r, echo=FALSE}
py$df_comercio_pd %>% 
  select(all_of(py$variables)) %>% 
  head(2)
```

]

.panel[.panel-name[Python con objeto R]

````
```{python}`r ''`
(r.df_comercio
  .filter(variables)
  .head(2))
```
````

```{python, echo=FALSE}
(r.df_comercio
  .filter(variables, axis=1)
  .head(2))
```

]



]



---

class: inverse, center, middle

# 1. Estad√≠stica descriptiva

---


.panelset[
.panel[.panel-name[R summary]

```{r summary}
df_comercio %>% summary()
```

]

.panel[.panel-name[Python .describe()]

Variables que no son object: 

```{python describe}
r.df_comercio.describe(exclude='object')
```

Variables tipo object: 

```{python describe_obj}
r.df_comercio.describe(include='object')
```

]


.panel[.panel-name[R skim(df)]

```{r skimr_gt}
py$df_comercio_pd %>% 
  select(where(is.numeric)) %>% 
  skimr::skim() %>% 
  select(-skim_type, -complete_rate) %>% 
  gt() %>% 
  tab_header(title=md('**Comercio exterior**: Argentina y M√©xico'), 
             subtitle='Estad√≠stica descriptiva') %>% 
  opt_align_table_header('left') %>% 
  fmt_number(columns=3:4) 
```

]

]


---

class: inverse, center, middle

# 2. Uni√≥n de dataframes

---

.panelset[
.panel[.panel-name[R]

```{r}
df <- df_comercio %>% 
  
  # Left join con datos de commodities
  left_join(df_commodities %>% 
              select(commodity_code, 
                     commodity_fullname_english, 
                     group_fullname_english), 
            by='commodity_code') %>% 
  
  # Left join con secciones
  left_join(df_secciones) %>%
  
  # Selecci√≥n de variables y renombrarlas
  select(
    a√±o             = year,
    pais            = reporter,
    socio           = partner, 
    commodity       = commodity_fullname_english,
    grupo           = group_fullname_english,
    seccion         = section_shortname_english, 
    expo            = trade_value_usd_exp,
    impo            = trade_value_usd_imp
  )
```

]

.panel[.panel-name[Python]
```{python}
df_py = (r.df_comercio

  # Left join con datos de commodities
  .merge(r.df_commodities[['commodity_code', 
                           'commodity_fullname_english', 
                           'group_fullname_english']], 
         on='commodity_code')
         
  # Left join con secciones
  .merge(r.df_secciones, on='section_code')
  
  # Renombrar variables
  .rename({
    'year'                       : 'a√±o',
    'reporter'                   : 'pais',
    'partner'                    : 'socio',
    'commodity_fullname_english' : 'commodity',
    'group_fullname_english'     : 'grupo',
    'section_shortname_english'  : 'seccion',
    'trade_value_usd_exp'        : 'expo',
    'trade_value_usd_imp'        : 'impo'
  }, axis=1)
  
  # Selecci√≥n de las columnas relevantes (mismas que df anterior en r)
  [r.df.columns]
  
  # √çndices que queden bien
  .reset_index(drop=True)
)
```

]


.panel[.panel-name[Dataframes generados]

üîπ R dataframe:

```{r}
df %>% head(2) %>% gt::gt()
```

üîπ Pandas dataframe: 

```{r}
py$df_py %>% head(2) %>% gt::gt()
```

]

.panel[.panel-name[Comparaci√≥n]

Se utiliza el paquete waldo para comparar los filtros generados:

```{r}
waldo::compare(data.frame(df),
               data.frame(py$df_py))
```

]

]

---

class: inverse, center, middle

# 3. Filtros

---

.panelset[
.panel[.panel-name[R]

```{r}
filtro_r <- df %>% 
  
  filter(
    
    # Condici√≥n simple (equivalencia)
    a√±o == 2019 &
      
    # Condici√≥n OR con funci√≥n quantile()
    (expo   > quantile(df$expo,0.6) | 
     impo   > quantile(df$impo,0.6) ) &
    
    # Filtro por expresi√≥n regular
    str_detect(tolower(commodity), 'metal')
  )
```

]

.panel[.panel-name[Python]

```{python}
filtro_py = (r.df

  .query("""
         a√±o == 2019 and                              \
                                                      \
         (expo   > expo.quantile(0.6) or              \
          impo   > impo.quantile(0.6)) and            \
                                                      \
         commodity.str.lower().str.contains('metal')
        """, 
        engine='python') 
        
  .reset_index(drop=True)
)
```
]

.panel[.panel-name[Dataframes generados]

üîπ R dataframe:

```{r}
filtro_r %>% head(2) %>% gt::gt()
```

üîπ Pandas dataframe: 

```{r}
py$filtro_py %>% head(2) %>% gt::gt()
```

]


.panel[.panel-name[Comparaci√≥n]

Se utiliza el paquete waldo para comparar los filtros generados:

```{r}
waldo::compare(data.frame(filtro_r),
               data.frame(py$filtro_py))
```
]

]









---

class: inverse, center, middle

# 3. Nuevas columnas

---

.panelset[
.panel[.panel-name[R]

```{r}
columnas_r <- df %>% 
  
  mutate(
    
    # C√°lculo
    expo_netas = expo - impo,
    
    # If else
    d_2020 = ifelse(a√±o==2020,1,0),
    
    # Case when
    categoria_extra = case_when(
      
      str_detect(commodity,'metal|machines') ~ 'Metal & maquinarias',
      str_detect(commodity,'animal|food|vegetable') ~ 'Cultivos y animales',
      TRUE ~ 'Otros'
      
    )
  )
```

]

.panel[.panel-name[Python]
```{python}
columnas_py = (r.df
  .assign(
    
    # C√°lculo
    expo_netas      = lambda x: x['expo'] - x['impo'],
    
    # If else
    d_2020          = lambda x: np.where(x['a√±o']==2020,1,0),
     
    # Case when
    categoria_extra = lambda x: np.select(
      
      [x['commodity'].str.contains('metal|machines'),
       x['commodity'].str.contains('animal|food|vegetable')],
      
      ['Metal & maquinarias',
       'Cultivos y animales'],
    
      default = 'Otros'
    )
    
  )
)
```

]

.panel[.panel-name[Dataframes generados]

üîπ R dataframe:

```{r}
columnas_r %>% head(2) %>% gt::gt()
```

üîπ Pandas dataframe: 

```{r}
py$columnas_py %>% head(2) %>% gt::gt()
```

]



.panel[.panel-name[Comparaci√≥n]
```{r}
waldo::compare(data.frame(columnas_r),
               data.frame(py$columnas_py))
```

]

]









---

class: inverse, center, middle

# 5. Agregaci√≥n

---

```{r}

```


---

class: inverse, center, middle

# 6. Formato wide a long / long a wide (pivot)

---

# Pivot wider

.panelset[
.panel[.panel-name[R]

```{r}
wider_r <- df %>% 
  
  group_by(seccion, a√±o) %>% 
  
  summarise(expo = sum(expo), .groups = 'keep') %>% 
  
  ungroup() %>% 
  
  pivot_wider(names_from=a√±o, 
              names_prefix='y_',
              values_from=expo) %>% 
  
  arrange(desc(y_2020, y_2019, y_2018, y_2017))
```

]

.panel[.panel-name[Python]
```{python}
wider_py = (r.df

 .assign(a√±o=lambda x: ['y_'+str(int(i)) for i in x['a√±o']])
 
 .groupby(['seccion','a√±o'], as_index=False)
 
 .agg(expo = ('expo','sum'))
 
 .pivot(index='seccion', 
        columns='a√±o',
        values='expo')
  
  .sort_values(['y_2020', 'y_2019', 'y_2018', 'y_2017'], 
               ascending=False)
  
  .reset_index(drop=False)

)

```
]

.panel[.panel-name[Dataframes generados]

üîπ R dataframe:

```{r}
wider_r %>% head(2) %>% gt::gt()
```

üîπ Pandas dataframe: 

```{r}
py$wider_py %>% head(2) %>% gt::gt()
```

]



.panel[.panel-name[Comparaci√≥n]
```{r}
waldo::compare(data.frame(wider_r),
               data.frame(py$wider_py))
```

]

]


# Pivot longer

.panelset[
.panel[.panel-name[R]

```{r}
longer_r <- wider_r %>% 
  
  pivot_longer(-seccion, names_to='a√±o', values_to='expo') %>% 
  
  mutate(a√±o=str_replace(a√±o, 'y_','')) %>% 
  
  arrange(seccion, a√±o)
```

]

.panel[.panel-name[Python]
```{python}
longer_py = (wider_py

  .melt(id_vars='seccion', value_vars=['y_2017','y_2018','y_2019','y_2020'], 
        value_name='expo')
  
  .assign(a√±o = lambda x: [i.replace('y_','') for i in x['a√±o']], 
          temp_var = lambda x: [i.lower().replace(' ','') for i in x['seccion']])
  
  .sort_values(['temp_var','a√±o'])
  
  .drop('temp_var',axis=1)
  
  .reset_index(drop=True)

)
```
]

.panel[.panel-name[Dataframes generados]

üîπ R dataframe:

```{r}
longer_r %>% head(2) %>% gt::gt()
```

üîπ Pandas dataframe: 

```{r}
py$longer_py %>% head(2) %>% gt::gt()
```

]



.panel[.panel-name[Comparaci√≥n]
```{r}
waldo::compare(data.frame(longer_r),
               data.frame(py$longer_py))
```

]

]


---

class: inverse, center, middle

# 7. Visualizaci√≥n

---

Se definen las secciones relevantes: 

```{r}
secciones_relevantes <- longer_r %>% 
  group_by(seccion) %>% 
  summarise(expo_4y=sum(expo)) %>% 
  ungroup() %>% 
  arrange(desc(expo_4y)) %>% 
  top_n(5) %>% pull(seccion)
```


---

.panelset[
.panel[.panel-name[R]

Reordenando las secciones por el promedio de las exportaciones:

```{r, fig.height=5, fig.width=10}
longer_r %>% 
  filter(seccion %in% secciones_relevantes) %>% 
  ggplot(aes(x=expo, y=reorder(seccion, expo)))+
    geom_boxplot()
```

]

.panel[.panel-name[Python]

.details[
```{python, out.width='50%', fig.align='center', code_folding=TRUE}
temp = longer_py[longer_py['seccion'].isin(r.secciones_relevantes)]

orden = (temp.groupby('seccion', as_index=False).expo.mean()
  .sort_values('expo', ascending=False)['seccion'])
```
]



```{python, out.width='50%', fig.align='center', out.height='50%', fig.width=10, fig.height=5}
sns.boxplot(x="expo", y="seccion", data=temp, order = orden)
```
]

]



---

# Links utiles

https://www.mit.edu/~amidi/teaching/data-science-tools/conversion-guide/r-python-data-manipulation/#

---

class: inverse, center, middle

# Contacto

<a href="https://karbartolome-blog.netlify.com"><i class="fa fa-link fa-fw"></i>&nbsp; karbartolome-blog.netlify.com</a><br>
<a href="http://twitter.com/karbartolome"><i class="fa fa-twitter fa-fw"></i>&nbsp; @karbartolome</a><br>
<a href="http://github.com/karbartolome"><i class="fa fa-github fa-fw"></i>&nbsp; @karbartolome</a><br>

---


class: center, middle

# Muchas gracias!!

Las slides fueron creadas con el paquete [**xaringan**](https://github.com/yihui/xaringan), utilizando el template de Rladies
















